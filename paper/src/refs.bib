
@article{prlicTenSimpleRules2012,
  langid = {english},
  title = {Ten {{Simple Rules}} for the {{Open Development}} of {{Scientific Software}}},
  volume = {8},
  issn = {1553-7358},
  url = {https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002802},
  doi = {10.1371/journal.pcbi.1002802},
  number = {12},
  journaltitle = {PLOS Computational Biology},
  urldate = {2019-09-22},
  date = {2012-12-06},
  pages = {e1002802},
  author = {Prlić, Andreas and Procter, James B.}
}

@article{baxterScientificSoftwareDevelopment2006,
  langid = {english},
  title = {Scientific {{Software Development Is Not}} an {{Oxymoron}}},
  volume = {2},
  issn = {1553-7358},
  url = {https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.0020087},
  doi = {10/bs5b5b},
  number = {9},
  journaltitle = {PLOS Computational Biology},
  urldate = {2019-09-22},
  date = {2006-09-08},
  pages = {e87},
  author = {Baxter, Susan M. and Day, Steven W. and Fetrow, Jacquelyn S. and Reisinger, Stephanie J.}
}

@article{altschulAnatomySuccessfulComputational2013,
  langid = {english},
  title = {The Anatomy of Successful Computational Biology Software},
  volume = {31},
  issn = {1546-1696},
  url = {https://www.nature.com/articles/nbt.2721},
  doi = {10.1038/nbt.2721},
  abstract = {Creators of software widely used in computational biology discuss the factors that contributed to their success},
  number = {10},
  journaltitle = {Nature Biotechnology},
  urldate = {2019-09-22},
  date = {2013-10},
  pages = {894-897},
  author = {Altschul, Stephen and Demchak, Barry and Durbin, Richard and Gentleman, Robert and Krzywinski, Martin and Li, Heng and Nekrutenko, Anton and Robinson, James and Rasband, Wayne and Taylor, James and Trapnell, Cole}
}

@article{huIntegratingModernResearch2007,
  title = {Integrating {{Modern Research}} into {{Numerical Computation Education}}},
  volume = {9},
  doi = {10/chdgqw},
  abstract = {Scientific computation has grown in scope over the years, but today's needs are far beyond what people have experienced in traditional scientific fields such as physics, chemistry, and biology. Although the term "computing" might also mean information processing as opposed to numerical computation, it's increasingly difficult to draw a clear boundary between the two. As more disciplines require or desire computational skills, the crowds we teach will include not only future engineers and natural scientists but also social scientists, business analysts, or even casual learners. People in this learning community will contribute to computational science not by theoretically exploring the properties of numerical algorithms, but by applying or modifying existing numerical methods or methodologies to successfully solve problems in their respective fields. How we teach numerical computation to the crowds must be taken far beyond the discussions on the relevance and advantages of computational software or programming languages. Whether repackaging what we teach would prepare students better - numerically speaking - remains to be seen. However, we must find ways to integrate modern scientific computation research results into our curricula.},
  number = {5},
  journaltitle = {Computing in Science Engineering},
  date = {2007-09},
  pages = {78-81},
  author = {Hu, C.}
}

@inproceedings{smithSoftwareCarpentry2018,
  title = {Beyond {{Software Carpentry}}},
  abstract = {About 20 years ago the need for scientists and engineers to have basic knowledge of software development skills and tools became apparent. Without these so-called software carpentry skills, developers were wasting time and compromising the quality of their work. Since that time great progress has been made with software carpentry, as evidenced by the growing understanding of the importance of tools, and by the growth of the namesake Software Carpentry foundation and other similar projects. With scientific software developers now prepared to move forward, we should turn our attention to the next logical step after carpentry: Software Engineering (SE) applied to Scientific Computing Software (SCS). Past attempts with SE for SCS have not always been successful; therefore, this paper proposes a vision for future success, including SE specifically adapting ideas to SCS, SCS recognizing the value of software artifacts other than the code, and all parties increasing the emphasis on empirical evidence and the quality of replicability. Several ideas are proposed for turning the proposed vision into a reality, including promoting requirements documentation for replicability, building assurance cases for correctness (and other qualities), and automatic generation of all documentation and code.},
  eventtitle = {2018 {{IEEE}}/{{ACM}} 13th {{International Workshop}} on {{Software Engineering}} for {{Science}} ({{SE4Science}})},
  booktitle = {2018 {{IEEE}}/{{ACM}} 13th {{International Workshop}} on {{Software Engineering}} for {{Science}} ({{SE4Science}})},
  date = {2018-06},
  pages = {32-39},
  author = {Smith, S.}
}

@article{wilsonSoftwareCarpentryGetting2006,
  title = {Software {{Carpentry}}: {{Getting Scientists}} to {{Write Better Code}} by {{Making Them More Productive}}},
  volume = {8},
  doi = {10.1109/MCSE.2006.122},
  shorttitle = {Software {{Carpentry}}},
  abstract = {For the past years, my colleagues and I have developed a one-semester course that teaches scientists and engineers the "common core" of modern software development. Our experience shows that an investment of 150 hours-25 of lectures and the rest of practical work-can improve productivity by roughly 20 percent. That's one day a week, one less semester in a master's degree, or one less year for a typical PhD. The course is called software carpentry, rather than software engineering, to emphasize the fact that it focuses on small-scale and immediately practical issues. All of the material is freely available under an open-source license at www.swc.scipy.org and can be used both for self-study and in the classroom. This article describes what the course contains, and why},
  number = {6},
  journaltitle = {Computing in Science Engineering},
  date = {2006-11},
  pages = {66-69},
  author = {Wilson, G.}
}

@article{michaud-agrawalMDAnalysisToolkitAnalysis2011,
  langid = {english},
  title = {{{MDAnalysis}}: {{A}} Toolkit for the Analysis of Molecular Dynamics Simulations},
  volume = {32},
  issn = {1096-987X},
  url = {https://www.onlinelibrary.wiley.com/doi/abs/10.1002/jcc.21787},
  doi = {10/dknb8h},
  shorttitle = {{{MDAnalysis}}},
  abstract = {MDAnalysis is an object-oriented library for structural and temporal analysis of molecular dynamics (MD) simulation trajectories and individual protein structures. It is written in the Python language with some performance-critical code in C. It uses the powerful NumPy package to expose trajectory data as fast and efficient NumPy arrays. It has been tested on systems of millions of particles. Many common file formats of simulation packages including CHARMM, Gromacs, Amber, and NAMD and the Protein Data Bank format can be read and written. Atoms can be selected with a syntax similar to CHARMM's powerful selection commands. MDAnalysis enables both novice and experienced programmers to rapidly write their own analytical tools and access data stored in trajectories in an easily accessible manner that facilitates interactive explorative analysis. MDAnalysis has been tested on and works for most Unix-based platforms such as Linux and Mac OS X. It is freely available under the GNU General Public License from http://mdanalysis.googlecode.com. © 2011 Wiley Periodicals, Inc. J Comput Chem 2011},
  number = {10},
  journaltitle = {Journal of Computational Chemistry},
  urldate = {2019-09-22},
  date = {2011},
  pages = {2319-2327},
  author = {Michaud‐Agrawal, Naveen and Denning, Elizabeth J. and Woolf, Thomas B. and Beckstein, Oliver}
}

@article{gobleBetterSoftwareBetter2014,
  title = {Better {{Software}}, {{Better Research}}},
  volume = {18},
  doi = {10/vjz},
  abstract = {Modern scientific research isn't possible without software. However, its vital role is often overlooked by funders, universities, assessment committees, and even the research community itself. This is a serious issue that needs urgent attention. This article raises a number of points concerning quality, code review, and openness; development practices and training in scientific computing; career recognition of research software engineers; and sustainability models for funding scientific software. We must get software recognized to be the first-class experimental scientific instrument that it is and get "better software for better research."},
  number = {5},
  journaltitle = {IEEE Internet Computing},
  date = {2014-09},
  pages = {4-8},
  author = {Goble, C.}
}

@article{basiliUnderstandingHighPerformanceComputingCommunity2008,
  title = {Understanding the {{High}}-{{Performance}}-{{Computing Community}}: {{A Software Engineer}}'s {{Perspective}}},
  volume = {25},
  doi = {10/fqs7r4},
  shorttitle = {Understanding the {{High}}-{{Performance}}-{{Computing Community}}},
  abstract = {Computational scientists developing software for HPC systems face unique software engineering issues. Attempts to transfer SE technologies to this domain must take these issues into account.},
  number = {4},
  journaltitle = {IEEE Software},
  date = {2008-07},
  pages = {29-36},
  author = {Basili, V. R. and Carver, J. C. and Cruzes, D. and Hochstein, L. M. and Hollingsworth, J. K. and Shull, F. and Zelkowitz, M. V.}
}


